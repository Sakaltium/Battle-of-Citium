<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ZpDICæ“ä½œãƒ»æ´¾ç”Ÿãƒ„ãƒ¼ãƒ«å®Œå…¨ç‰ˆ</title>
  <style>
    body { font-family: sans-serif; margin: 20px; background: #f5f5f5; }
    input, textarea, select, button { display: block; margin: 8px 0; padding: 6px; width: 100%; max-width: 500px; }
    textarea { height: 80px; }
    pre { background: #fff; padding: 10px; max-width: 800px; overflow: auto; white-space: pre-wrap; word-wrap: break-word; }
    h2 { margin-top: 30px; }
    #progressBar { width: 100%; max-width: 500px; height: 20px; background: #ccc; margin-top: 5px; }
    #progressFill { height: 100%; width: 0%; background: #4caf50; transition: width 0.3s ease; }
  </style>
</head>
<body>
  <h1>ZpDIC æ“ä½œï¼†æ´¾ç”Ÿãƒ„ãƒ¼ãƒ«</h1>
  <label>APIã‚­ãƒ¼:</label><input id="apiKey" autocomplete="off" spellcheck="false">
  <label>æ¬å…¥å£è¾æ›¸ID:</label><input id="inputDict" autocomplete="off" spellcheck="false">
  <label>æ¬å‡ºå£è¾æ›¸ID:</label><input id="outputDict" autocomplete="off" spellcheck="false">

  <hr><h2>ğŸ”¹ å˜èªæ´¾ç”Ÿè¨­å®š</h2>
  <textarea id="derivationRules" placeholder="dâ†’t\naâ†’e ãªã©æ”¹è¡ŒåŒºåˆ‡ã‚Š"></textarea>
  <input id="rulesetName" placeholder="ãƒ«ãƒ¼ãƒ«ã‚»ãƒƒãƒˆå" autocomplete="off" spellcheck="false">
  <button onclick="saveRuleset()">ãƒ«ãƒ¼ãƒ«ã‚»ãƒƒãƒˆä¿å­˜</button>
  <select id="rulesetSelect" size="5" style="max-width: 250px;"></select>
  <button onclick="loadRuleset()">é¸æŠå‘¼ã³å‡ºã—</button>
  <button onclick="deleteRuleset()">é¸æŠå‰Šé™¤</button>

  <label>å˜èªç•ªå·ç¯„å›²ï¼ˆä¾‹: 1-500ï¼‰:</label>
  <input id="wordRange" autocomplete="off" spellcheck="false">
  <label>ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³æ™‚é–“ï¼ˆç§’ï¼‰:</label>
  <input id="cooldown" type="number" min="0" step="0.1" value="6.0" style="width:120px;">

  <button onclick="runDerivation()">æ´¾ç”Ÿé–‹å§‹</button>
  <pre id="progress"></pre>
  <div id="progressBar"><div id="progressFill"></div></div>

  <hr><h2>ğŸ”§ å˜èªç·¨é›†ãƒ»æ¤œç´¢</h2>
  <input id="editWordNumber" placeholder="å˜èªç•ªå·ï¼ˆæ–°è¦ã¯ç©ºï¼‰">
  <input id="editWordName" placeholder="å˜èªå">
  <input id="editPronunciation" placeholder="ç™ºéŸ³">
  <input id="editVariations" placeholder="å¤‰åŒ–å½¢(|åŒºåˆ‡ã‚Š)">
  <input id="editTags" placeholder="ã‚¿ã‚°(|åŒºåˆ‡ã‚Š)">
  <textarea id="editInformations" placeholder="æƒ…å ± ã‚¿ã‚¤ãƒˆãƒ«|å†…å®¹ æ”¹è¡ŒåŒºåˆ‡ã‚Š"></textarea>
  <button onclick="submitWord()">ä¿å­˜</button>
  <button onclick="deleteWord()">å‰Šé™¤</button>
  <button onclick="loadWord()">èª­ã¿è¾¼ã¿</button>
  <pre id="wordResult"></pre>

  <h3>ğŸ” å˜èªæ¤œç´¢</h3>
  <input id="searchText" placeholder="æ¤œç´¢èª">
  <select id="searchMode">
    <option value="both">å˜èªï¼‹è¨³èª</option>
    <option value="name">å˜èªå</option>
    <option value="information">å†…å®¹</option>
    <option value="variation">å¤‰åŒ–å½¢</option>
  </select>
  <button onclick="searchWords()">æ¤œç´¢</button>
  <pre id="searchResult"></pre>

  <script>
    const apiBase = 'https://zpdic.ziphil.com/api/v0';
    function getHeaders() {
      return {
        'Content-Type': 'application/json',
        'X-Api-Key': document.getElementById('apiKey').value
      };
    }

    function applyRules(text, rules) {
      let res = text;
      for (const rule of rules) {
        const [from, to] = rule.split('â†’').map(s => s.trim());
        if (from) res = res.replace(new RegExp(from, 'g'), to);
      }
      return res;
    }

    async function runDerivation() {
      const inId = document.getElementById('inputDict').value.trim();
      const outId = document.getElementById('outputDict').value.trim();
      const range = document.getElementById('wordRange').value.trim();
      const cooldown = parseFloat(document.getElementById('cooldown').value);
      const rules = document.getElementById('derivationRules').value.trim().split('\n').filter(Boolean);

      if (!range.includes('-')) return alert('å˜èªç•ªå·ç¯„å›²ã‚’æ­£ã—ãå…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆä¾‹: 1-500ï¼‰');
      const [start, end] = range.split('-').map(Number);
      if (isNaN(start) || isNaN(end) || start > end) return alert('ç¯„å›²ãŒä¸æ­£ã§ã™');

      const total = end - start + 1;
      let completed = 0;
      let retryList = [];

      function updateProgress() {
        document.getElementById('progress').textContent = `${completed} / ${total} æ´¾ç”Ÿå®Œäº†`;
        document.getElementById('progressFill').style.width = `${(completed / total) * 100}%`;
      }

      async function processBatch(ids) {
        await Promise.all(ids.map(async id => {
          try {
            const res = await fetch(`${apiBase}/dictionary/${inId}/word/${id}`, { headers: getHeaders() });
            if (!res.ok) throw new Error();
            const w = (await res.json()).word;

            let equivalents = w.equivalents || [];
            let informations = (w.informations || []).filter(inf => {
              const titleLower = (inf.title || '').toLowerCase();
              const textLower = (inf.text || '').toLowerCase();
              if (titleLower.includes('è¨³èª') || textLower.includes('è¨³èª')) {
                let text = inf.text || '';
                const match = text.match(/è¨³èª[:ï¼š]?\s*(.+)/);
                if (match && match[1]) {
                  const words = match[1].split(/[,ã€\s]+/).map(s => s.trim()).filter(Boolean);
                  words.forEach(wrd => {
                    if (!equivalents.find(e => e.name === wrd)) {
                      equivalents.push({ name: wrd });
                    }
                  });
                } else {
                  if (!equivalents.find(e => e.name === text)) {
                    equivalents.push({ name: text });
                  }
                }
                return false;
              }
              return true;
            });

            const body = {
              word: {
                name: applyRules(w.name, rules),
                pronunciation: applyRules(w.pronunciation || '', rules),
                equivalents,
                tags: w.tags,
                informations: informations.map(inf => ({
                  title: applyRules(inf.title, rules),
                  text: applyRules(inf.text, rules)
                })),
                variations: w.variations,
                relations: w.relations
              }
            };

            const postRes = await fetch(`${apiBase}/dictionary/${outId}/word`, {
              method: 'POST',
              headers: getHeaders(),
              body: JSON.stringify(body)
            });
            if (!postRes.ok) throw new Error();
            completed++;
            updateProgress();
          } catch (e) {
            retryList.push(id);
          }
        }));
      }

      updateProgress();
      const allIds = Array.from({ length: total }, (_, i) => start + i);
      for (let i = 0; i < allIds.length; i += 10) {
        const batch = allIds.slice(i, i + 10);
        await processBatch(batch);
        await new Promise(r => setTimeout(r, cooldown * 1000));
      }

      let retryCount = 0;
      while (retryList.length > 0 && retryCount < 3) {
        const current = [...retryList];
        retryList = [];
        for (let i = 0; i < current.length; i += 10) {
          await processBatch(current.slice(i, i + 10));
          await new Promise(r => setTimeout(r, cooldown * 1000));
        }
        retryCount++;
      }

      if (retryList.length > 0) {
        alert(`âš ï¸ ä¸€éƒ¨ã®å˜èªã¯å¤±æ•—ã—ã¾ã—ãŸ: ${retryList.join(', ')}`);
      } else {
        alert('âœ… æ´¾ç”Ÿå®Œäº†');
      }
    }
  </script>
</body>
</html>
