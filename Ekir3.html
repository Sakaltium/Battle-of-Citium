<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>ZpDICæ“ä½œãƒ»æ´¾ç”Ÿãƒ„ãƒ¼ãƒ«å®Œå…¨ç‰ˆï¼ˆæ”¹è‰¯ç‰ˆï¼‰</title>
<style>
body {
  font-family: sans-serif;
  margin: 20px;
  background: #f5f5f5;
}
input, textarea, select, button {
  display: block;
  margin: 8px 0;
  padding: 6px;
  width: 100%;
  max-width: 500px;
  box-sizing: border-box;
}
textarea {
  height: 80px;
  resize: vertical;
}
pre {
  background: #fff;
  padding: 10px;
  max-width: 800px;
  overflow: auto;
  white-space: pre-wrap;
  word-wrap: break-word;
  border: 1px solid #ccc;
  border-radius: 4px;
  min-height: 100px;
}
h2 {
  margin-top: 30px;
}
#progressBarContainer {
  width: 100%;
  max-width: 800px;
  height: 20px;
  background: #ddd;
  border-radius: 10px;
  overflow: hidden;
  margin-top: 8px;
  margin-bottom: 12px;
}
#progressBar {
  height: 100%;
  width: 0;
  background: #4caf50;
  transition: width 0.3s ease;
}
</style>
</head>
<body>
<h1>ZpDIC æ“ä½œï¼†æ´¾ç”Ÿãƒ„ãƒ¼ãƒ«</h1>

<label>APIã‚­ãƒ¼:</label>
<input id="apiKey" autocomplete="off" spellcheck="false">

<label>æ¬å…¥å£è¾æ›¸ID:</label>
<input id="inputDict" autocomplete="off" spellcheck="false">

<label>æ¬å‡ºå£è¾æ›¸ID:</label>
<input id="outputDict" autocomplete="off" spellcheck="false">

<hr>
<h2>ğŸ”¹ å˜èªæ´¾ç”Ÿè¨­å®š</h2>
<textarea id="derivationRules" placeholder="dâ†’t\n aâ†’e ãªã©æ”¹è¡ŒåŒºåˆ‡ã‚Š"></textarea>

<input id="rulesetName" placeholder="ãƒ«ãƒ¼ãƒ«ã‚»ãƒƒãƒˆå" autocomplete="off" spellcheck="false">
<button onclick="saveRuleset()">ãƒ«ãƒ¼ãƒ«ã‚»ãƒƒãƒˆä¿å­˜</button>

<select id="rulesetSelect" size="5" style="max-width: 250px;"></select>
<button onclick="loadRuleset()">é¸æŠå‘¼ã³å‡ºã—</button>
<button onclick="deleteRuleset()">é¸æŠå‰Šé™¤</button>

<label>å˜èªç•ªå·ç¯„å›²ï¼ˆä¾‹: 1-500ï¼‰:</label>
<input id="wordRange" autocomplete="off" spellcheck="false">

<label>ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³æ™‚é–“ï¼ˆç§’ã€APIä»•æ§˜ã«åˆã‚ã›ã¦æ¨å¥¨6ç§’ï¼‰:</label>
<input id="cooldown" type="number" min="0" step="0.1" value="6.0" style="width:120px;" autocomplete="off" spellcheck="false">

<button onclick="runDerivation()">æ´¾ç”Ÿé–‹å§‹</button>

<div id="progressBarContainer" aria-label="é€²æ—ãƒãƒ¼">
  <div id="progressBar"></div>
</div>
<pre id="progress"></pre>

<hr>
<h2>ğŸ”§ å˜èªç·¨é›†ãƒ»æ¤œç´¢</h2>
<input id="editWordNumber" placeholder="å˜èªç•ªå·ï¼ˆæ–°è¦ã¯ç©ºï¼‰" autocomplete="off" spellcheck="false">
<input id="editWordName" placeholder="å˜èªå" autocomplete="off" spellcheck="false">
<input id="editPronunciation" placeholder="ç™ºéŸ³" autocomplete="off" spellcheck="false">
<input id="editVariations" placeholder="å¤‰åŒ–å½¢(|åŒºåˆ‡ã‚Š)" autocomplete="off" spellcheck="false">
<input id="editTags" placeholder="ã‚¿ã‚°(|åŒºåˆ‡ã‚Š)" autocomplete="off" spellcheck="false">
<textarea id="editInformations" placeholder="æƒ…å ± ã‚¿ã‚¤ãƒˆãƒ«|å†…å®¹ æ”¹è¡ŒåŒºåˆ‡ã‚Š"></textarea>
<button onclick="submitWord()">ä¿å­˜</button>
<button onclick="deleteWord()">å‰Šé™¤</button>
<button onclick="loadWord()">èª­ã¿è¾¼ã¿</button>
<pre id="wordResult"></pre>

<h3>ğŸ” å˜èªæ¤œç´¢</h3>
<input id="searchText" placeholder="æ¤œç´¢èª" autocomplete="off" spellcheck="false">
<select id="searchMode">
  <option value="both">å˜èªï¼‹è¨³èª</option>
  <option value="name">å˜èªå</option>
  <option value="information">å†…å®¹</option>
  <option value="variation">å¤‰åŒ–å½¢</option>
</select>
<button onclick="searchWords()">æ¤œç´¢</button>
<pre id="searchResult"></pre>

<script>
const apiBase = 'https://zpdic.ziphil.com/api/v0';

function getHeaders() {
  return {
    'Content-Type': 'application/json',
    'X-Api-Key': document.getElementById('apiKey').value
  };
}

// ãƒ«ãƒ¼ãƒ«ã‚»ãƒƒãƒˆç®¡ç†
function saveRuleset() {
  const name = document.getElementById('rulesetName').value.trim();
  if (!name) return alert('åå‰ãŒå¿…è¦ã§ã™');
  const rules = document.getElementById('derivationRules').value.trim().split('\n').filter(Boolean);
  const sets = JSON.parse(localStorage.getItem('derivationRulesets') || '[]');
  const existing = sets.find(s => s.name === name);
  if (existing) existing.rules = rules;
  else sets.push({ name, rules });
  localStorage.setItem('derivationRulesets', JSON.stringify(sets));
  alert('ä¿å­˜å®Œäº†');
  renderRulesets();
}
function renderRulesets() {
  const sets = JSON.parse(localStorage.getItem('derivationRulesets') || '[]');
  const sel = document.getElementById('rulesetSelect');
  sel.innerHTML = '';
  sets.forEach(s => {
    const opt = document.createElement('option');
    opt.value = s.name;
    opt.textContent = s.name;
    sel.appendChild(opt);
  });
}
function loadRuleset() {
  const sel = document.getElementById('rulesetSelect');
  if (!sel.value) return alert('ãƒ«ãƒ¼ãƒ«ã‚»ãƒƒãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„');
  const sets = JSON.parse(localStorage.getItem('derivationRulesets') || '[]');
  const found = sets.find(s => s.name === sel.value);
  if (found) document.getElementById('derivationRules').value = found.rules.join('\n');
}
function deleteRuleset() {
  const sel = document.getElementById('rulesetSelect');
  if (!sel.value) return alert('ãƒ«ãƒ¼ãƒ«ã‚»ãƒƒãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„');
  let sets = JSON.parse(localStorage.getItem('derivationRulesets') || '[]');
  sets = sets.filter(s => s.name !== sel.value);
  localStorage.setItem('derivationRulesets', JSON.stringify(sets));
  renderRulesets();
}

function applyRules(text, rules) {
  let res = text;
  for (const rule of rules) {
    const [from, to] = rule.split('â†’').map(s => s.trim());
    if (from) {
      try {
        // ç‰¹æ®Šæ–‡å­—ãŒã‚ã‚Œã°ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
        const escapedFrom = from.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        res = res.replace(new RegExp(escapedFrom, 'g'), to);
      } catch {
        // ä¸‡ä¸€ã‚¨ãƒ©ãƒ¼ãªã‚‰ã‚¹ã‚­ãƒƒãƒ—
      }
    }
  }
  return res;
}

// é€²æ—ãƒãƒ¼æ›´æ–°
function updateProgressBar(completed, total) {
  const bar = document.getElementById('progressBar');
  const percent = total === 0 ? 0 : Math.floor((completed / total) * 100);
  bar.style.width = percent + '%';
  document.getElementById('progress').textContent = `å‡¦ç†ä¸­: ${completed} / ${total} (${percent}%) å®Œäº†`;
}

// æ´¾ç”Ÿå‡¦ç†ï¼ˆ10ä»¶ãšã¤ãƒãƒƒãƒã§cooldownç§’é–“éš”ã€æœ€å¤§3å›ãƒªãƒˆãƒ©ã‚¤ï¼‰
async function runDerivation() {
  const inId = document.getElementById('inputDict').value.trim();
  const outId = document.getElementById('outputDict').value.trim();
  const range = document.getElementById('wordRange').value.trim();
  if (!range.includes('-')) return alert('å˜èªç•ªå·ç¯„å›²ã‚’æ­£ã—ãå…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆä¾‹: 1-500ï¼‰');
  const [start, end] = range.split('-').map(Number);
  if (isNaN(start) || isNaN(end) || start > end) return alert('ç¯„å›²ãŒä¸æ­£ã§ã™');

  const rules = document.getElementById('derivationRules').value.trim().split('\n').filter(Boolean);
  let cooldown = parseFloat(document.getElementById('cooldown').value);
  if (isNaN(cooldown) || cooldown < 0) cooldown = 6.0;
  cooldown = cooldown * 1000; // msã¸å¤‰æ›

  const allIds = [];
  for (let i = start; i <= end; i++) allIds.push(i);

  let retryList = [];
  let completedCount = 0;
  const totalCount = allIds.length;

  updateProgressBar(0, totalCount);

  function delay(ms) {
    return new Promise(r => setTimeout(r, ms));
  }

  async function fetchWord(id) {
    const res = await fetch(`${apiBase}/dictionary/${inId}/word/${id}`, { headers: getHeaders() });
    if (!res.ok) throw new Error(`å˜èªå–å¾—å¤±æ•—: ${id}`);
    return (await res.json()).word;
  }

  async function processBatch(ids) {
    const words = [];
    for (const id of ids) {
      try {
        const w = await fetchWord(id);
        let equivalents = w.equivalents || [];
        let informations = (w.informations || []).filter(inf => {
          const titleLower = (inf.title || '').toLowerCase();
          const textLower = (inf.text || '').toLowerCase();
          if (titleLower.includes('è¨³èª') || textLower.includes('è¨³èª')) {
            let text = inf.text || '';
            const match = text.match(/è¨³èª[:ï¼š]?\s*(.+)/);
            if (match && match[1]) {
              const words = match[1].split(/[,ã€\s]+/).map(s => s.trim()).filter(Boolean);
              words.forEach(wrd => {
                if (!equivalents.find(e => e.name === wrd)) {
                  equivalents.push({ name: wrd });
                }
              });
            } else {
              if (!equivalents.find(e => e.name === text)) {
                equivalents.push({ name: text });
              }
            }
            return false;
          }
          return true;
        });

        const newName = applyRules(w.name, rules);
        const newPron = applyRules(w.pronunciation || '', rules);
        const newInfos = informations.map(inf => ({
          title: applyRules(inf.title, rules),
          text: applyRules(inf.text, rules)
        }));

        words.push({
          name: newName,
          pronunciation: newPron,
          equivalents,
          tags: w.tags,
          informations: newInfos,
          variations: w.variations,
          relations: w.relations
        });

      } catch (e) {
        console.error(e);
        retryList.push(id);
      }
    }

    if (words.length > 0) {
      const body = { words };
      const postRes = await fetch(`${apiBase}/dictionary/${outId}/words`, {
        method: 'POST',
        headers: getHeaders(),
        body: JSON.stringify(body)
      });
      if (!postRes.ok) {
        console.error(`ãƒãƒƒãƒç™»éŒ²å¤±æ•—: çŠ¶æ…‹ã‚³ãƒ¼ãƒ‰ ${postRes.status}`);
        retryList.push(...ids);
      } else {
        completedCount += words.length;
        updateProgressBar(completedCount, totalCount);
      }
    }
  }

  for (let i = 0; i < allIds.length; i += 10) {
    const batch = allIds.slice(i, i + 10);
    await processBatch(batch);
    await delay(cooldown);
  }

  let retryCount = 0;
  while (retryList.length > 0 && retryCount < 3) {
    const currentRetry = [...retryList];
    retryList = [];
    retryCount++;
    for (let i = 0; i < currentRetry.length; i += 10) {
      const batch = currentRetry.slice(i, i + 10);
      await processBatch(batch);
      await delay(cooldown);
    }
  }

  if (retryList.length > 0) {
    alert(`âš ï¸ ä¸€éƒ¨ã®å˜èªã¯å‡¦ç†ã§ãã¾ã›ã‚“ã§ã—ãŸ: ${retryList.join(', ')}`);
  } else {
    alert('âœ… æ´¾ç”Ÿå‡¦ç†å®Œäº†');
  }
}

// å˜èªä¿å­˜
async function submitWord() {
  const dict = document.getElementById('inputDict').value.trim();
  if(!dict) return alert('æ¬å…¥å£è¾æ›¸IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
  const id = document.getElementById('editWordNumber').value.trim();
  const method = id ? 'PUT' : 'POST';
  const path = id ? `/word/${id}` : '/word';
  const infos = document.getElementById('editInformations').value.trim().split('\n').map(l => {
    const [t, x] = l.split('|');
    return { title: t?.trim(), text: x?.trim() };
  }).filter(i => i.title || i.text);
  const body = {
    word: {
      name: document.getElementById('editWordName').value.trim(),
      pronunciation: document.getElementById('editPronunciation').value.trim(),
      equivalents: [],
      tags: document.getElementById('editTags').value.split('|').filter(Boolean),
      informations: infos,
      variations: document.getElementById('editVariations').value.split('|').filter(Boolean).map(n => ({ name: n })),
      relations: []
    }
  };
  try {
    const res = await fetch(`${apiBase}/dictionary/${dict}${path}`, {
      method,
      headers: getHeaders(),
      body: JSON.stringify(body)
    });
    alert(res.ok ? 'âœ… ä¿å­˜å®Œäº†' : `âŒ ã‚¨ãƒ©ãƒ¼ ${res.status}`);
  } catch {
    alert('âŒ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼');
  }
}

// å˜èªèª­ã¿è¾¼ã¿
async function loadWord() {
  const dict = document.getElementById('inputDict').value.trim();
  const id = document.getElementById('editWordNumber').value.trim();
  if (!dict) return alert('æ¬å…¥å£è¾æ›¸IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
  if (!id) return alert('å˜èªç•ªå·ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
  try {
    const res = await fetch(`${apiBase}/dictionary/${dict}/word/${id}`, { headers: getHeaders() });
    if (!res.ok) return alert('èª­ã¿è¾¼ã¿å¤±æ•—');
    const w = (await res.json()).word;
    document.getElementById('editWordName').value = w.name;
    document.getElementById('editPronunciation').value = w.pronunciation || '';
    document.getElementById('editTags').value = (w.tags || []).join('|');
    document.getElementById('editVariations').value = (w.variations || []).map(v => v.name).join('|');
    document.getElementById('editInformations').value = (w.informations || []).map(i => i.title + '|' + i.text).join('\n');
    document.getElementById('wordResult').textContent = JSON.stringify(w, null, 2);
  } catch {
    alert('âŒ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼');
  }
}

// å˜èªå‰Šé™¤
async function deleteWord() {
  const dict = document.getElementById('inputDict').value.trim();
  const id = document.getElementById('editWordNumber').value.trim();
  if (!dict) return alert('æ¬å…¥å£è¾æ›¸IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
  if (!id) return alert('å˜èªç•ªå·ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
  try {
    const res = await fetch(`${apiBase}/dictionary/${dict}/word/${id}`, { method: 'DELETE', headers: getHeaders() });
    alert(res.ok ? 'âœ… å‰Šé™¤å®Œäº†' : 'âŒ å‰Šé™¤å¤±æ•—');
  } catch {
    alert('âŒ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼');
  }
}

// å˜èªæ¤œç´¢
async function searchWords() {
  const dict = document.getElementById('inputDict').value.trim();
  const text = document.getElementById('searchText').value.trim();
  const mode = document.getElementById('searchMode').value;
  if (!dict) return alert('æ¬å…¥å£è¾æ›¸IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
  if (!text) return alert('æ¤œç´¢èªã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
  try {
    const res = await fetch(`${apiBase}/dictionary/${dict}/words?text=${encodeURIComponent(text)}&mode=${mode}&type=part&limit=100`, { headers: getHeaders() });
    if (!res.ok) return alert('æ¤œç´¢å¤±æ•—');
    const js = await res.json();
    document.getElementById('searchResult').textContent = JSON.stringify(js.words || js, null, 2);
  } catch {
    alert('âŒ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼');
  }
}

renderRulesets();
</script>
</body>
</html>
